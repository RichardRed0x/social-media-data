#!/usr/bin/env python3

# tsu - time series utility

import os
import csv
from datetime import datetime

class Config:
    data_dir            = "data"
    export_csv_filename = "export.csv"

# Define and catch our own exception to avoid intercepting language and library exceptions.
class ValidationError(Exception):
    pass

def parse(entry, int_val=True):
    if len(entry) != 2:
        raise ValidationError("entry must have exactly 2 fields: " + str(entry))
    s1, s2 = entry
    try:
        tsi = int(s1)
    except ValueError as e:
        raise ValidationError("timestamp is not an integer: '{}'".format(s1)) from e
    try:
        dt = datetime.utcfromtimestamp(tsi)
    except Exception as e:
        raise ValidationError("cannot parse datetime from timestamp: '{}'".format(tsi)) from e
    if int_val:
        try:
            val = int(s2)
        except ValueError as e:
            raise ValidationError("value is not an integer: '{}'".format(s2)) from e
    else:
        if len(s2) > 0:
            val = s2
        else:
            raise ValidationError("value is empty")
    return dt, val

STRING_VALUE_FILES = frozenset(["errors.csv"])

def validate(path, view=False):
    with open(path, newline='') as csvfile:
        r = csv.reader(csvfile)
        int_values = os.path.basename(path) not in STRING_VALUE_FILES
        prev_dt = datetime.min
        for row in r:
            try:
                dt, val = parse(row, int_values)
                if dt <= prev_dt:
                    raise ValidationError("timestamp '{}' must be greater than '{}'".format(dt, prev_dt))
                prev_dt = dt
                if view:
                    if int_values:
                        print(dt, "{:>6,}".format(val))
                    else:
                        print(dt, val)
            except ValidationError as e:
                print("err {}:{}: {}".format(path, r.line_num, e))

def cmd_view(args):
    validate(args.file, True)

def cmd_validate(args):
    path = args.path
    if os.path.isfile(path):
        validate(path)
    elif os.path.isdir(path):
        for curdir, dirs, files in os.walk(path):
            for fname in files:
                if fname.endswith(".csv"):
                    validate(os.path.join(curdir, fname))

def strip_prefix(s, p):
    if s.startswith(p):
        return s[len(p):]
    else:
        return s

def export_append_rows(rows, fpath):
    if not fpath.endswith(".csv"):
        return
    dirname, fname = os.path.split(fpath)
    # metric name is the file name without extension
    metric = os.path.splitext(fname)[0]
    # strip the data directory prefix path component
    plat_acc = strip_prefix(dirname, Config.data_dir + os.sep)
    # platform is the first path component, account is the rest
    platform, account = plat_acc.split(os.sep, maxsplit=1)
    with open(fpath, newline='') as csvfile:
        reader = csv.reader(csvfile)
        for row in reader:
            ts, val = row
            rows.append((ts, platform, account, metric, val))

def export_csv(path, outname):
    rows = []
    if os.path.isfile(path):
        export_append_rows(rows, path)
    for curdir, dirs, files in os.walk(path):
        for fname in files:
            export_append_rows(rows, os.path.join(curdir, fname))

    # sort by timestamp, in-place
    rows.sort(key = lambda entry: entry[0])

    # overwrite existing file
    with open(outname, "w", newline="") as outfile:
        writer = csv.writer(outfile, lineterminator="\n")
        writer.writerow(("timestamp", "platform", "account", "metric", "value"))
        writer.writerows(rows)
    print("file saved:", outname)

def cmd_export_csv(args):
    export_csv(args.path, args.output)

def make_arg_parser():
    import argparse
    parser = argparse.ArgumentParser(description="time series utility")
    subparsers = parser.add_subparsers(dest="command", title="commands")

    parser_validate = subparsers.add_parser("validate", help="validate time series files")
    parser_validate.add_argument("path", nargs='?', default=Config.data_dir, help="path to search csv files")
    parser_validate.set_defaults(func=cmd_validate)

    parser_view = subparsers.add_parser("view", help="view time series file")
    parser_view.add_argument("file", help="file to view")
    parser_view.set_defaults(func=cmd_view)

    parser_export = subparsers.add_parser("export", help="export data from arbitrary tree of csv files into a single file, overwriting it")
    parser_export.add_argument("path", nargs='?', default=Config.data_dir, help="path to search csv files")
    parser_export.add_argument("--output", default=Config.export_csv_filename, help="file name to save")
    parser_export.set_defaults(func=cmd_export_csv)

    return parser

def main():
    parser = make_arg_parser()
    args = parser.parse_args()

    if args.command:
        try:
            args.func(args)
        except BrokenPipeError:
            # silence error when e.g. piping into `less` and quitting before reading all
            pass
    else:
        parser.print_usage()

if __name__ == "__main__":
    main()
